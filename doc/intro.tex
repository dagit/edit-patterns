\section{Introduction}
%% 1. Describe the problem

Version control systems (VCS's) track the evolution of software over time in the form
of a sequence of changes to the plain text representation of the code.
We would like to be able to characterize the changes to files in a software
project according to the type of change that they represent.  The ability to
map these changes to the syntax of the language, instead of its raw text
representation, will allow them to be understood in terms of the language
constructs themselves.  Doing so will allow us to identify patterns of
changes at the abstract syntax level to support insight at a deeper level
than achievable by examining raw text differences.  For example, in
an operating system kernel, a set of drivers may need to be updated to use a
new mutual exclusion mechanism. In this example, blocks of code that access
specific resources need to be updated to take a semaphore before proceeding.

Finding common patterns for the changes to a source file gives us the ability
to understand, at a higher level, what sorts of revisions are happening. If we
already know to look for changes to semaphore handling we may think to use a
textual search tool, such as {\tt grep}, to search the source code for
functions related to semaphores. Instead, suppose we have the challenge that we
are not familiar with the source code and we would like to understand at a
structural level what types of changes were needed to add support for the new
semaphores.

Our contributions described in this work are:

\begin{itemize}

\item We show that structural differencing algorithms that operate on the
abstract syntax tree or parse tree of a language can be used to map text
differences stored in a VCS to a form where syntactic changes can be reasoned
about.

\item We show that anti-unification can be used to map similar changes to a
generalized change pattern.

\item We show that clustering by a tree similarity metric allows differences
to be grouped such that the families of changes to generalize via anti-
unification can be inferred from the differences using a basic similarlity
threshold.

\end{itemize}

In this paper, we briefly describe the building blocks of our work and show
preliminary results of this methodology as applied to version control
repositories for open source projects available online.  The projects studied
in this paper are ANTLR and Clojure, both written in Java.

\jason{Is it ANTLR or Antlr?}

\subsection{Motivation}

We would like to be able to take existing software projects and use the history
stored in the VCS to answer questions which may be important to software
developers, software project managers, language designers, and static analysis
tools.

For example the manager of a large software project may lead an effort to port
an existing application to multicore.  After a successful port an interesting
question to ask might be, what types of changes were needed to add mutual
exclusion? Another question might be, do seemingly simple changes require large
changes in the source code and why?  Answers to these questions could help
inform future software development on the code base, such as making decisions
about when is the right time to undertake a large restructuring.

Language designers may want to know whether specific syntatic constructs would
make the language more productive for users. Taking an example from Java, we
might consider the addition of the {\tt foreach} loop construct. This feature
could be partially justified by doing an analysis of existing source code to
determine that most for-loops iterate over the entire collection. To strength
this argument, it would be insightful to know what is the impact of maintaining
the code without {\tt foreach}. For example, if refactoring the code commonly
leads to editing the bounds to match the collection used, then the argument in
favor of adding {\tt foreach} is strengthened, as now it helps to prevent a
class of bugs where programmers forget to update the bounds.

Software developers joining a new project or team are expected to learn the
source code that they will be working with. We would like to provide these
programmers with tools that aid them in this task by allowing them to see what
types of changes other team members have made in the past. Software developers
may also want to compare the changes that happen in response to related bugs,
hoping to find opportunities to improve software quality, either by searching
for buggy patterns in the source code or making a tool to detect the pattern in
new code.

\jason{cut this?}

In our own work, we seek to develop tools that help us identify patterns that
can be fed into existing static analysis tools and rewriting systems.

\subsection{Related work}

The use of version control repositories as a source of data to study changes
to code over time is not new, but our approach to the problem is novel.
Neamtiu~\cite{neamtiu05understand} uses a similar approach of analyzing the
abstract syntax tree of code in successive program versions, but focuses on
detecting change occurrences only instead of going a step further and
attempting to identify any common patterns of change that can be found.  
Other groups have focused on identifying patterns based on common
refactorings that can be identified in the code~\cite{weissgerber06identify},
and seek to infer simple abstract rules that encapsulate the changes
that they detect~\cite{kim07automatic}.  For example, one such rule could
indicate that for all calls that match a certain pattern, an additional
argument should be added to their argument list.

This goal of generating abstract rules is similar to our goal of inferring
generic patterns via anti-unification.  What differs with our approach is
that we presuppose no knowledge of the underlying language beyond the structure
provided by the language parser and its mapping to the aterm format.  As such,
it is challenging to build rules that give an interpretation to the program
abstract syntax, such as ``append an argument to the function call'', since
we do not provide a mapping from the concept of ``function call'' to a pattern
of AST nodes.  By instead emitting templates in terms of the language AST in
aterm form, we are able to keep the tool as language-neutral as possible.
