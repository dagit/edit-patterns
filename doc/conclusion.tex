\section{Conclusions and future work}

We have shown that patterns of change over the lifetime of a project can be
obtained through analysis of its version control history.  The use of tree
differencing and tree similarity measures, as well as the antiunification
algorithm for computing generalized patterns, allows this large volume of
difference data to be distilled into a compact form in which changes can be
studied at the level of the base language syntax.  Analysis of the size and
count of groups of similar changes as a function of a similarity threshold
provides a disciplined way to identify generalizations of changes identified by
the tool.

Our work has been performed using a generic, language neutral term
representation allowing the same techniques to be applied to other languages
given appropriate parsing infrastructure and a mapping from language-specific
abstract syntax forms to the generic annotated term form.  Minimal
parameterization of the tool is necessary to then consume these terms, with
language-specific parameters largely focused on specific nodes within the term
that correspond to semantically useful subtree roots for providing context to
tree differences.

In Section~\ref{sec:threshold}, we showed that our approach can highlight the
evolution of code structurally. In fact, our example of the for-loop precisely
supports the hypothetical language designer argument laid out in
Section~\ref{sec:motivation}.

In Section~\ref{sec:clojure}, we were able to find related changes in different
files that happened as part of the same commit. Not only were we able to remove
noise compared to line-based diff, but we were also looking at the Clojure
source for the first time and able to see an important relationship between the
internals of the classes in those two files. As programmers who are completely
new to the Clojure source we were able to gain valuable insight.

%% Future work after this point

Our experiment relied on a simple replay of the history of a software project.
There are other meaningful ways to generate the set of files to analyze. One
such example would be to correlate code changes to bug fixes and bug reports
and then push those changes through our workflow to find patterns.  As
mentioned in Section\ref{sec:motivation} this may provide a support to quality
assurance practices.

In Section~\ref{sec:weaving} we explored one way to extract context. Many
different heuristics would be suitable here. Studying the trade-offs of
different heuristics would allow us to fine tune our approach depending on the
application and what we wanted to learn about the source code.

\subsection{Acknowledgments}

This work was supported in part by the US Department of
Energy Office of Science, Advanced Scientific Computing Research
contract no. DE-SC0004968.  Additional support was provided by Galois,
Inc.
